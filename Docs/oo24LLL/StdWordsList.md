**Референс стандартных слов oo24LLL**

# I. Языковые конструкции

**ПРЕЛЮДИЯ:**

- `FILE_META (key) (...value...)`
- `GLOBAL_META (key) (...value...)`
- `STRINGS_TABLE...`
  - `^START`
  - `^END`
- - `...END_TABLE`
- `USE_MODULE (modname)`

<hr>

**ОСНОВНОЙ КОД:**

- `(value) (wordname) DEFINE` - определить слово (переменную) в текущем замыкании.
- `(wordname) DEFINE... (values) ...END` - определить отложенное слово (функцию/ленивую переменную) в текущем замыкании. Семантика схожа с `DEFINE` (но значение ленивое).
- `(wordname) DELETE` - удалить слово в словаре.

- `(condition) CONDITION... (body) ...END` - контейнер условия. В его теле можно располагать блоки `THEN...` / `ELSE...`.
- `THEN... (body) ...END` - выполняет `body`, если условие ИСТИННО. Должно находиться внутри тела `CONDITION...`.
- `ELSE... (body) ...END` - выполняет `body`, если условие ЛОЖНО. Должно находиться внутри тела `CONDITION...`.

- `LOOP... (body) ...END` - циклически выполнять тело конструкции. Для управления исполнением цикла существуют специальные инструкции.
- - `BREAK_LOOP` - остановить цикл и выйти из него.
- - `SKIP_ITERATION` - пропустить итерацию, перейти в начало тела цикла (аналог 'contunue' из популярных языков).

# II. Основные инструкции (core-instructions)

- `(top) dup` - дублировать значение на верхушке стека.
- `(subtop) (top) subdup` - дублировать значение (`subtop`) на ПРЕД-верхушке стека.
- `(top) drop` - снять (удалить) значение с верхушки стека.

<!-- Набор символов `@@-` используется для разделения пространств имён определений. Использование его в коде может привести к неопределённому поведению (UB). -->
- `(wordname) is_defined` - определено ли указанное слово?
- `(wordname) [local]` - сделать переменную локальной (эмулировать). На самом деле, просто добавляет к её названию полный путь до данной переменной.
- `(wordname) pop_scope` - подняться на одну область видимости вверх. Не факт, что в ней будет объявлено данное определение.
- `(wordname) upper_definition` - перейти к более верхнему определению. Схоже с `pop_scope`, однако гарантирует, что если есть "более глобальное" определение данного слова - будет возвращено именно оно, пускай для этого придётся подняться на несколько областей видимости вверх.

- `(index) string` - скопировать строку (под указанным индексом) из таблицы строк.
- `(message) print` - вывести сообщение в `stdout` (если он, конечно, есть). Снимает значение с верхушки стека.
- `(exitcode) exit_program` - завершает программу с указанным кодом выхода.
- `(number) to_int` - \[FUTURE] преобразовать значение с плавающей точкой в целочисленное.
- `(number) to_float` - \[FUTURE] преобразовать целочисленное значение в значение с плавающей точкой.
- `true` - булево значение "истина". Равняется `1 (int)`; мета-тип: `Boolean`.
- `false` - булево значение "ложь". Равняется `0 (int)`; мета-тип: `Boolean`.
- `null` - специальное значение, обозначающее отсутствие значения. Равняется `0 (int)`; мета-тип: `Null`.

- `(a) (b) [+]` - сложить числа.
- `(a) (b) [-]` - вычесть из числа `a` число `b`.
- `(a) (b) [*]` - перемножить числа.
- `(a) (b) [/]` - **целочисленно** поделить число `a` на число `b`.
- `(a) (b) [%]` - получить остаток от деления числа `a` на число `b`.
- `(a) increment` - увеличить число на 1.
- `(a) decrement` - убавить число на 1.

- `(a) (b) [==]` - проверить равенство числа `a` числу `b`. *Не использовать для строк.*
- `(a) (b) [!=]` - проверить НЕравенство числа `a` числу `b`. *Не использовать для строк.*
- `(a) (b) [>]` - проверить: число `a` больше числа `b`?
- `(a) (b) [>=]` - проверить: число `a` больше или равно числу `b`?
- `(a) (b) [<]` - проверить: число `a` меньше числа `b`?
- `(a) (b) [<=]` - проверить: число `a` меньше или равно числу `b`?
- `(condition) not` - логическое отрицание условия. Работает с булевыми значениями.
- `(value) bitnot` - побитовое отрицание. Работает с числами.
- `(first) (second) and` - побитовое "И" - и, по совместительству, логическое. Работает и с числами, и с булевыми значениями.
- `(first) (second) or` - побитовое "ИЛИ" - и, по совместительству, логическое. Работает и с числами, и с булевыми значениями.
- `(first) (second) bitxor` - побитовое "ИСКЛЮЧАЮЩЕЕ ИЛИ". Работает с числами.
- `(value) (shift) [<<]` - побитовый сдвиг влево. Работает с числами.
- `(value) (shift) [>>]` - побитовый сдвиг вправо с учётом знака. Работает с числами.
- `(value) (shift) [>>>]` - побитовый сдвиг вправо с заполнением нулями (беззнаковый). Работает с числами.

# III. Расширенные модули

## `std/m_math`

- `(num) m_floor`
- `(num) m_ceil`
- `(num) m_round`
<!-- и иные методы объекта Math -->

## `std/s_string`

- `(first) (second) s_concat` - конкатенировать (объединить, "склеить") две указанные строки.
- `(string) (index) s_at`
- `(string) (index) s_set_at`
- `(source) (searchstr) s_index_of`
- `(source) (searchstr) s_includes`
- `(string) s_uppercase`
- `(string) s_lowercase`
- `(string) s_capitalize`
<!-- про s_atoi() / подобные, а ещё всякие replace() и иные методы из JS/PY -->

## `std/ac_array`
> "Array-collection"

...

## `std/sc_stack`
> "Stack-collection"

...

## `std/mc_map`
> "Map-collection" (key-value map)

...

# IV. "Рефлексия", взаимодействие с интерпретатором
> Здесь, под "рефлексией" имеется в виду хранение метаданных и взаимодействие с ними, а также доступ ко внутренним функциям или управление состоянием интерпретатора.
> Данный набор функций у каждой реализации интерпретатора свой. *Иные* интерпретаторы не гарантируют наличия нижеперечисленных функций.
> Данный набор функций включён *всегда*, однако, если вы собираетесь использовать данные функции - вы должны подключить модуль явно. Название зависит от реализации интерпретатора, однако в этой реализации данный модуль имеет название `intrinsic/oo24-theo`.

- `(value) (type) @__AssignType__@` - без всяких преобразований, установить значению указанный тип представления.
- `(value) (type) @__CastTo__@` - преобразовать значение к указанному типу. Данные будут изменены (например, при преобразовании типа `Float` -> `Integer`, отсекается дробная часть).
- `@__DisableExceptions__@` - \[FUTURE] отключить выбрасывание RuntimeException.
- `@__EnableExceptions__@` - \[FUTURE] вернуть выбрасывание RuntimeException.
- `(scopename) @__EnterScope__@` - эмулировать начало области видимости.
- `@__ExitScope__@` - эмулировать конец области видимости.
