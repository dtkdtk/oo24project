# Обработка конструкций

Основа всего - *определения*. Они используются не только как значения переменных / тела функций (*определение слова* и *ленивое определение слова* соответственно), а как *тела любых конструкций*.

На самом деле, конструкции `THEN...` / `ELSE...` / `LOOP...` **создают *анонимные* определения**.

Например:

```rb
15 SomeNumber-A DEFINE
99 SomeNumber-B DEFINE
15 99 [==]
CONDITION...
  THEN...
    "Equals" print
  ...END

  ELSE...
    "NotEquals" print
  ...END
...END
```

...будет транслировано в...: (*приблизительный код*)

```rb
Dictionary:
  @__AnonymScope:1__@ | "Equals" print
  @__AnonymScope:2__@ | "NotEquals" print
Code:
  15 SomeNumber-A DEFINE #Не изменено, т.к. не является блоком кода
  99 SomeNumber-B DEFINE # (нельзя вычислить на этапе компиляции; да и не нужно нам это)
  15 99 [==]
  #НАЧАЛО ИНСТРУКЦИИ УСЛОВИЯ
    "@__AnonymScope:1__@" (название слова, что будет выполнено, если условие равно 'true')
    "@__AnonymScope:2__@" (..аналогично, но при 'false')
    @__ExecuteCondition__@
  #КОНЕЦ ИНСТРУКЦИИ УСЛОВИЯ
```



# Инструкции "с пост-блоком"

Все стандартные конструкции являются ничем иным как просто словами с нативным определением, которые могут быть преобразованы в "плоские выражения" на этапе интерпретации кода.

Кроме правила обработки чисел (первый случай спец.обработки слов) и правила обработки встраиваемых строк (второй случай спец.обработки слов), есть ещё и **правило обработки пост-блочной инструкции** (третий случай спец.обработки слов):
1. Если слово оканчивается на троеточие (`...`) - включается режим обработки пост-блока инструкции.
2. Происходит чтение (не исполнение!) последующего блока кода (до инструкции конца - `...END`, расположенной на том же уровне вложенности). Поток Читателя перенаправляется из функции `InterpretMainCode()` в функцию `InterpretDefinition()`.
3. Прочитанный блок кода помещается в поле `LLL_STATE#StateStorage.PostBlock`.
4. Управление возвращается в основную функцию `InterpretMainCode()` (из которой и была вызвана функция `InterpretDefinition()`), в которой происходит вызов самой инструкции. Обратите внимание: троеточие сохраняется (это часть названия слова).
5. Определение должно быть нативной функцией, иначе - выбрасывается ошибка.
